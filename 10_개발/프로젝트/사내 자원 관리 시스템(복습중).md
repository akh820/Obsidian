복습 가이드 : [[STUDY_GUIDE 진척도(세부, 간단)]]

equip-request -> resource-tracker 로 자체 개발(복습)

뭐부터해야할까? 

프로젝트 생성? 

ERD 설계? 나중에 일단 카피뜨고나서

PostgreSQL을 선택한 이유 ? 
=> MySql은 많이 써보기도 했고, **아 하지마 일단은** 무조건 그대로 지금 중요한거아님, 나중에 마이그레이션이라던가 추가 공부가능

ERD CLOUD : https://www.erdcloud.com/d/5ZzSpLs8pvqrDGhpq

![[Pasted image 20260114151705.png]]
[[Entity 흐름 대충 그림]]

초기설정 백엔드 [[00_Java & SpringBoot]] 참고
엔티티 설계 

일단 공통부터? 
[[Java - Spring 네이밍 규칙]]

##### domain
###### BaseEntity
```Java
package backend.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.PrePersist;
import lombok.Getter;

/*
실제 테이블이 아닌, 베이스 클래스라서 Base 명시
실제 도메인 엔티니는 간결하게 이름만 예) User
*/
@MappedSuperclass // [[@MappedSuperclass]]
@Getter // @Data를 사용하지 않은 이유는 @Setter 때문에 id 나 다른게 변경 위험이 있기때문에
public abstract class BaseEntity { // abstract 가 상속받아야지만 사용할 수 있도록 직접 생성을 막는 용도
  
  @Id
  @GeneratedValue(strategy= GenerationType.IDENTITY) // [[GenerationType 전략]]
  private Long id; // Long 은 객체 타입 이라서 null 허용을 하기 때문에 사용

  @Column(name = "created_at", nullable = false, updatable = false)
  private LocalDateTime createdAt; //[[LocalDateTime]] , DB에 저장시 주의

  @PrePersist // [[JPA 라이프사이클 콜백]]
  protected void onCreate() { // [[접근 제어자]]
    createdAt = LocalDateTime.now();
  }
}

```

###### User
```Java
package backend.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity // 이 클래스는 DB 테이블과 매핑되는 엔티티야! 라는 이야기 필수 annotation
@Table(name = "users") // 단수형도 상관없으나, 복수형이 더 많이 쓰임
@Getter // Setter의 문제점으로 암호화가 안될 수 있으니 Builder 를 사용, 수정시에는 비즈니스 메서드 사용
@NoArgsConstructor(access = AccessLevel.PROTECTED) // JPA가 기본 생성자가 필요한 이유 [[리플렉션]] , [[@NoArgsConstructor]]
@AllArgsConstructor // [[@AllArgsConstructor]]
@Builder // 빌더패턴을 사용하는 이유 [[@Builder]]
public class User extends BaseEntity {

    @Column(nullable = false, unique = true)
    private String email;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String name;

    @Enumerated(EnumType.STRING) // [[enum]]
    @Column(nullable = false)
    private UserRole role;

    public enum UserRole {
        USER, ADMIN
    }
}

```
###### Equipment (버전, 메서드 남음)
```Java
package backend.domain;

import jakarta.persistence.*;
import lombok.*;

/*
Wrapper 클래스 쓴이유 ? 
유연성(추후 nullable 변경 가능)
일관성(팀 습관?)
습관(null 가능성 대비)
*/

@Entity
@Table(name = "equipment")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class Equipment extends BaseEntity {

	//이름 없으면 자동으로 기본이름 사용
    @Column(nullable = false)
    private String name;

	//String으로 두면varchar(255)가 될수있으니 따로 정의
    @Column(columnDefinition = "TEXT")
    private String description;

    @Column(nullable = false)
    private String category;

    @Column(name = "image_url")
    private String imageUrl;

    @Column(nullable = false)
    private Integer stock;

    @Column(nullable = false)
    private Boolean available;

    @Version
    @Builder.Default
    private Long version = 0L;

    public void decreaseStock(int quantity) {
        if (this.stock < quantity) {
            throw new IllegalStateException("재고가 부족합니다.");
        }
        this.stock -= quantity;
    }

    public void increaseStock(int quantity) {
        this.stock += quantity;
    }

    public void update(String name, String description, String category,
                       String imageUrl, Integer stock, Boolean available) {
        this.name = name;
        this.description = description;
        this.category = category;
        this.imageUrl = imageUrl;
        this.stock = stock;
        this.available = available;
    }
}

```
###### EquipmentRequest(메서드 나음)
```Java
package backend.domain;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "equipment_requests")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class EquipmentRequest extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY) // [[@ManyToOne, FetchType]]
    // 여기서 Many는 equipmentRequest 엔티티, One은 User 엔티티
    // [[N + 1 문제]] , [[Eager, Lazy 조회 시점]]
    // [[Java & MySql 타입 매핑표]]
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private RequestStatus status;

    @Column(name = "reject_reason")
    private String rejectReason;

    @Column(name = "processed_at")
    private LocalDateTime processedAt;
    //fetch = FetchType.EAGET => LAZY
    //mappedBy 에는 나 , 속성에는 엮이는 상대방
    @OneToMany(
	    mappedBy = "equipmentRequest", 
	    cascade = CascadeType.ALL, 
	    fetch = FetchType.LAZY) // [[OneToMany 옵션]], Lazy가 기본값이나 명시적으로적음
    // [[양방향, 단방향을 결정하는 조건(ManyToOne, OneToMany)]]
    @Builder.Default // [[@Builder]] , Builder와 함께 쓸때 Final은 안붙임
    private List<RequestItem> items = new ArrayList<>();

    public enum RequestStatus {
        PENDING, APPROVED, REJECTED
    }
	//Entity에 두는 로직은 도메인 로직이라고 부르며, 자기 자신의 상태만 변경
    public void approve() {
        this.status = RequestStatus.APPROVED;
        this.processedAt = LocalDateTime.now();
    }

    public void reject(String reason) {
        this.status = RequestStatus.REJECTED;
        this.rejectReason = reason;
        this.processedAt = LocalDateTime.now();
    }

    // RequestItem 양방향 연관관계 편의 메서드
    // [[양방향 예시 코드]]
    public void addItem(RequestItem item) {
        this.items.add(item);
        // 객체 주소와 연결하기 위함
        item.setEquipmentRequest(this);
    }
}

```
###### RequestItem ( 아무것도 안함 )
```Java
package backend.domain;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Table(name = "request_items")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class RequestItem extends BaseEntity {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "request_id", nullable = false)
    private EquipmentRequest equipmentRequest;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "equipment_id", nullable = false)
    private Equipment equipment;

    @Column(nullable = false)
    private Integer quantity;

    // EquipmentRequest 양방향 연관관계 편의 메서드
    public void setEquipmentRequest(EquipmentRequest equipmentRequest) {
        this.equipmentRequest = equipmentRequest;
    }
}

```
##### repository
###### UserRepository
```Java
package backend.repository;

import backend.domain.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;
//Jpa<다룰 엔티티, User의 ID타입(BaseEntity의 Long id)>
public interface UserRepository extends JpaRepository<User, Long> {

	//결과가 없을 수 있으므로 null 방지
	//[[Spring Data JPA 쿼리 메서드(Query Method) <-> SQL 매칭]]
    Optional<User> findByEmail(String email);

    boolean existsByEmail(String email);
}

```
