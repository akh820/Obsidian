#면접 #ORM
[[Eager, Lazy 조회 시점]]

## 🎯 단순하게 정리

```java

// 10개 조회 (1번 쿼리)

List<EquipmentRequest> requests = findAll();

// 반복문 안에서 연관 데이터 접근

for (EquipmentRequest req : requests) {

    req.getUser().getName();  // ← 여기서 매번 쿼리 (10번)

}
```

**반복문 안에서 DB 조회가 반복됨 = N+1 문제** 

---

## 📌 왜 이렇게 되냐면

JPA가 기본적으로 **지연 로딩**이라서:

1. 처음엔 
    
    ```
    EquipmentRequest
    ```
    
    만 가져옴
2. ```
    getUser()
     호출 시점에 User를 DB에서 조회
3. 반복문이니까 → 매번 조회 → **반복 쿼리 발생**

---

## 💡 결론

|질문|답|
|---|---|
|반복문 때문?|✅ 네, 맞아요!|
|정확히는?|반복문 + 지연 로딩 조합|
|해결?|Fetch Join으로 미리 다 가져오기|

**"반복문 안에서 연관 엔티티 접근할 때 발생"**이라고 이해하시면 정확합니다! 👍
## N+1 문제는 JPA만?

**아니요, ORM 전체의 문제입니다:**

- **Hibernate (JPA 구현체)** - 발생
- **Node.js의 Sequelize/TypeORM** - 발생
- **Python의 SQLAlchemy** - 발생
- **Ruby on Rails의 ActiveRecord** - 발생

**왜?**

- 객체를 개별로 가져와서 연관 데이터 조회하는 ORM 특성 때문

**순수 SQL은?**

- N+1 안 생김 (JOIN 직접 작성)
- 대신 불편함

**ORM = 편리함 + N+1 문제 (해결 필요)**

