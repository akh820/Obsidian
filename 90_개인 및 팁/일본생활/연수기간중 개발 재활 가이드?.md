[[JavaJsReact]]

# 게시판 프로젝트 실전 가이드

> 같은 게시판을 2가지 스택으로 만든다. 
> 1차: Java + Spring Boot + React(JS) 
> 2차: Kotlin + Spring Boot + React(TS)

---

## 만들 기능

```
게시판 (Board)
├── 게시글 CRUD (제목, 내용, 작성자, 작성일, 수정일)
├── 게시글 목록 (페이징 + 검색)
├── 댓글 CRUD (게시글 1 : 댓글 N)
├── 회원가입 / 로그인 (JWT)
├── 로그인한 사람만 글쓰기/수정/삭제
└── 본인 글만 수정/삭제 가능
```

---

## 1차: Java + Spring Boot + React(JS)

### Backend: Java + Spring Boot

#### Step 1. 프로젝트 생성

[start.spring.io](https://start.spring.io/)

```
- Language: Java
- Build: Gradle (Groovy)
- Java: 17
- Dependencies:
  - Spring Web
  - Spring Data JPA
  - Spring Security
  - Validation
  - H2 Database (개발용, 나중에 MySQL로 교체 가능)
  - Lombok
```

#### Step 2. DB 설계 + Entity (1시간)

```
users
├── id (Long, PK, AUTO_INCREMENT)
├── username (String, UNIQUE, NOT NULL)
├── password (String, NOT NULL)
├── created_at (LocalDateTime)

posts
├── id (Long, PK, AUTO_INCREMENT)
├── title (String, NOT NULL, max 100)
├── content (String, NOT NULL, TEXT)
├── user_id (Long, FK → users.id)
├── created_at (LocalDateTime)
├── updated_at (LocalDateTime)

comments
├── id (Long, PK, AUTO_INCREMENT)
├── content (String, NOT NULL)
├── user_id (Long, FK → users.id)
├── post_id (Long, FK → posts.id)
├── created_at (LocalDateTime)
```

**Entity 코드 — 여기서 익힐 것: JPA 어노테이션 전부**

```java
@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false)
    private String password;

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @OneToMany(mappedBy = "user")
    private List<Post> posts = new ArrayList<>();

    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
}

@Entity
@Table(name = "posts")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@EntityListeners(AuditingEntityListener.class)
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String title;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @OneToMany(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Comment> comments = new ArrayList<>();

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    private LocalDateTime updatedAt;

    public Post(String title, String content, User user) {
        this.title = title;
        this.content = content;
        this.user = user;
    }

    public void update(String title, String content) {
        this.title = title;
        this.content = content;
    }
}

@Entity
@Table(name = "comments")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@EntityListeners(AuditingEntityListener.class)
public class Comment {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id", nullable = false)
    private Post post;

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    public Comment(String content, User user, Post post) {
        this.content = content;
        this.user = user;
        this.post = post;
    }
}
```

**application.yml**

```yaml
spring:
  datasource:
    url: jdbc:h2:mem:board
    driver-class-name: org.h2.Driver
    username: sa
    password:
  h2:
    console:
      enabled: true
  jpa:
    hibernate:
      ddl-auto: create
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  data:
    jpa:
      repositories:
        enabled: true

jwt:
  secret: your-secret-key-at-least-32-characters-long
  expiration: 86400000  # 24시간
```

#### Step 3. Repository (15분)

```java
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    boolean existsByUsername(String username);
}

public interface PostRepository extends JpaRepository<Post, Long> {
    Page<Post> findByTitleContaining(String keyword, Pageable pageable);
    Page<Post> findAllByOrderByCreatedAtDesc(Pageable pageable);
}

public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByPostIdOrderByCreatedAtDesc(Long postId);
}
```

#### Step 4. DTO (30분)

```java
// --- Request DTOs ---

public record SignupRequest(
    @NotBlank(message = "아이디는 필수입니다")
    @Size(min = 3, max = 50)
    String username,

    @NotBlank(message = "비밀번호는 필수입니다")
    @Size(min = 4, max = 100)
    String password
) {}

public record LoginRequest(
    @NotBlank String username,
    @NotBlank String password
) {}

public record PostCreateRequest(
    @NotBlank(message = "제목은 필수입니다")
    @Size(max = 100)
    String title,

    @NotBlank(message = "내용은 필수입니다")
    String content
) {}

public record PostUpdateRequest(
    @NotBlank @Size(max = 100) String title,
    @NotBlank String content
) {}

public record CommentCreateRequest(
    @NotBlank(message = "댓글 내용은 필수입니다")
    String content
) {}

// --- Response DTOs ---

public record PostListResponse(
    Long id,
    String title,
    String author,
    int commentCount,
    LocalDateTime createdAt
) {
    public static PostListResponse from(Post post) {
        return new PostListResponse(
            post.getId(),
            post.getTitle(),
            post.getUser().getUsername(),
            post.getComments().size(),
            post.getCreatedAt()
        );
    }
}

public record PostDetailResponse(
    Long id,
    String title,
    String content,
    String author,
    Long authorId,
    List<CommentResponse> comments,
    LocalDateTime createdAt,
    LocalDateTime updatedAt
) {
    public static PostDetailResponse from(Post post) {
        return new PostDetailResponse(
            post.getId(),
            post.getTitle(),
            post.getContent(),
            post.getUser().getUsername(),
            post.getUser().getId(),
            post.getComments().stream()
                .map(CommentResponse::from)
                .toList(),
            post.getCreatedAt(),
            post.getUpdatedAt()
        );
    }
}

public record CommentResponse(
    Long id,
    String content,
    String author,
    Long authorId,
    LocalDateTime createdAt
) {
    public static CommentResponse from(Comment comment) {
        return new CommentResponse(
            comment.getId(),
            comment.getContent(),
            comment.getUser().getUsername(),
            comment.getUser().getId(),
            comment.getCreatedAt()
        );
    }
}

public record TokenResponse(String token, String username) {}
```

#### Step 5. Service (1시간)

```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class PostService {

    private final PostRepository postRepository;
    private final UserRepository userRepository;

    // 글 목록 (페이징)
    public Page<PostListResponse> getPosts(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());
        return postRepository.findAll(pageable)
            .map(PostListResponse::from);
    }

    // 글 검색
    public Page<PostListResponse> searchPosts(String keyword, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("createdAt").descending());
        return postRepository.findByTitleContaining(keyword, pageable)
            .map(PostListResponse::from);
    }

    // 글 상세
    public PostDetailResponse getPost(Long id) {
        Post post = postRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("게시글을 찾을 수 없습니다."));
        return PostDetailResponse.from(post);
    }

    // 글 작성
    @Transactional
    public PostDetailResponse createPost(PostCreateRequest request, Long userId) {
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("사용자를 찾을 수 없습니다."));
        Post post = new Post(request.title(), request.content(), user);
        postRepository.save(post);
        return PostDetailResponse.from(post);
    }

    // 글 수정 (본인만)
    @Transactional
    public PostDetailResponse updatePost(Long id, PostUpdateRequest request, Long userId) {
        Post post = postRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("게시글을 찾을 수 없습니다."));

        if (!post.getUser().getId().equals(userId)) {
            throw new AccessDeniedException("본인의 글만 수정할 수 있습니다.");
        }

        post.update(request.title(), request.content());
        return PostDetailResponse.from(post);
    }

    // 글 삭제 (본인만)
    @Transactional
    public void deletePost(Long id, Long userId) {
        Post post = postRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("게시글을 찾을 수 없습니다."));

        if (!post.getUser().getId().equals(userId)) {
            throw new AccessDeniedException("본인의 글만 삭제할 수 있습니다.");
        }

        postRepository.delete(post);
    }
}

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class CommentService {

    private final CommentRepository commentRepository;
    private final PostRepository postRepository;
    private final UserRepository userRepository;

    @Transactional
    public CommentResponse createComment(Long postId, CommentCreateRequest request, Long userId) {
        Post post = postRepository.findById(postId)
            .orElseThrow(() -> new EntityNotFoundException("게시글을 찾을 수 없습니다."));
        User user = userRepository.findById(userId)
            .orElseThrow(() -> new EntityNotFoundException("사용자를 찾을 수 없습니다."));

        Comment comment = new Comment(request.content(), user, post);
        commentRepository.save(comment);
        return CommentResponse.from(comment);
    }

    @Transactional
    public void deleteComment(Long commentId, Long userId) {
        Comment comment = commentRepository.findById(commentId)
            .orElseThrow(() -> new EntityNotFoundException("댓글을 찾을 수 없습니다."));

        if (!comment.getUser().getId().equals(userId)) {
            throw new AccessDeniedException("본인의 댓글만 삭제할 수 있습니다.");
        }

        commentRepository.delete(comment);
    }
}

@Service
@RequiredArgsConstructor
public class AuthService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final JwtUtil jwtUtil;

    @Transactional
    public TokenResponse signup(SignupRequest request) {
        if (userRepository.existsByUsername(request.username())) {
            throw new IllegalArgumentException("이미 존재하는 아이디입니다.");
        }

        User user = new User(
            request.username(),
            passwordEncoder.encode(request.password())
        );
        userRepository.save(user);

        String token = jwtUtil.generateToken(user.getId(), user.getUsername());
        return new TokenResponse(token, user.getUsername());
    }

    public TokenResponse login(LoginRequest request) {
        User user = userRepository.findByUsername(request.username())
            .orElseThrow(() -> new IllegalArgumentException("아이디 또는 비밀번호가 틀렸습니다."));

        if (!passwordEncoder.matches(request.password(), user.getPassword())) {
            throw new IllegalArgumentException("아이디 또는 비밀번호가 틀렸습니다.");
        }

        String token = jwtUtil.generateToken(user.getId(), user.getUsername());
        return new TokenResponse(token, user.getUsername());
    }
}
```

#### Step 6. JWT + Security 설정 (1시간)

```java
// JwtUtil.java
@Component
public class JwtUtil {

    @Value("${jwt.secret}")
    private String secret;

    @Value("${jwt.expiration}")
    private long expiration;

    public String generateToken(Long userId, String username) {
        return Jwts.builder()
            .setSubject(String.valueOf(userId))
            .claim("username", username)
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + expiration))
            .signWith(Keys.hmacShaKeyFor(secret.getBytes()), SignatureAlgorithm.HS256)
            .compact();
    }

    public Long getUserId(String token) {
        Claims claims = parseClaims(token);
        return Long.parseLong(claims.getSubject());
    }

    public boolean validateToken(String token) {
        try {
            parseClaims(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    private Claims parseClaims(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(Keys.hmacShaKeyFor(secret.getBytes()))
            .build()
            .parseClaimsJws(token)
            .getBody();
    }
}

// JwtAuthenticationFilter.java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                     HttpServletResponse response,
                                     FilterChain filterChain)
            throws ServletException, IOException {

        String header = request.getHeader("Authorization");

        if (header != null && header.startsWith("Bearer ")) {
            String token = header.substring(7);
            if (jwtUtil.validateToken(token)) {
                Long userId = jwtUtil.getUserId(token);
                UsernamePasswordAuthenticationToken auth =
                    new UsernamePasswordAuthenticationToken(userId, null, List.of());
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        }

        filterChain.doFilter(request, response);
    }
}

// SecurityConfig.java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers(HttpMethod.POST, "/api/auth/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/posts/**").permitAll()
                .requestMatchers("/h2-console/**").permitAll()
                .anyRequest().authenticated()
            )
            .headers(headers -> headers.frameOptions(f -> f.disable())) // H2 console
            .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

#### Step 7. Controller (30분)

```java
@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final AuthService authService;

    @PostMapping("/signup")
    public ResponseEntity<TokenResponse> signup(@RequestBody @Valid SignupRequest request) {
        return ResponseEntity.status(HttpStatus.CREATED).body(authService.signup(request));
    }

    @PostMapping("/login")
    public ResponseEntity<TokenResponse> login(@RequestBody @Valid LoginRequest request) {
        return ResponseEntity.ok(authService.login(request));
    }
}

@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    @GetMapping
    public ResponseEntity<Page<PostListResponse>> getPosts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String keyword) {

        if (keyword != null && !keyword.isBlank()) {
            return ResponseEntity.ok(postService.searchPosts(keyword, page, size));
        }
        return ResponseEntity.ok(postService.getPosts(page, size));
    }

    @GetMapping("/{id}")
    public ResponseEntity<PostDetailResponse> getPost(@PathVariable Long id) {
        return ResponseEntity.ok(postService.getPost(id));
    }

    @PostMapping
    public ResponseEntity<PostDetailResponse> createPost(
            @RequestBody @Valid PostCreateRequest request,
            Authentication authentication) {
        Long userId = (Long) authentication.getPrincipal();
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(postService.createPost(request, userId));
    }

    @PutMapping("/{id}")
    public ResponseEntity<PostDetailResponse> updatePost(
            @PathVariable Long id,
            @RequestBody @Valid PostUpdateRequest request,
            Authentication authentication) {
        Long userId = (Long) authentication.getPrincipal();
        return ResponseEntity.ok(postService.updatePost(id, request, userId));
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deletePost(
            @PathVariable Long id,
            Authentication authentication) {
        Long userId = (Long) authentication.getPrincipal();
        postService.deletePost(id, userId);
        return ResponseEntity.noContent().build();
    }
}

@RestController
@RequestMapping("/api/posts/{postId}/comments")
@RequiredArgsConstructor
public class CommentController {

    private final CommentService commentService;

    @PostMapping
    public ResponseEntity<CommentResponse> createComment(
            @PathVariable Long postId,
            @RequestBody @Valid CommentCreateRequest request,
            Authentication authentication) {
        Long userId = (Long) authentication.getPrincipal();
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(commentService.createComment(postId, request, userId));
    }

    @DeleteMapping("/{commentId}")
    public ResponseEntity<Void> deleteComment(
            @PathVariable Long postId,
            @PathVariable Long commentId,
            Authentication authentication) {
        Long userId = (Long) authentication.getPrincipal();
        commentService.deleteComment(commentId, userId);
        return ResponseEntity.noContent().build();
    }
}
```

#### Step 8. 예외 처리 (15분)

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<Map<String, String>> handleNotFound(EntityNotFoundException e) {
        return ResponseEntity.status(404).body(Map.of("error", e.getMessage()));
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<Map<String, String>> handleForbidden(AccessDeniedException e) {
        return ResponseEntity.status(403).body(Map.of("error", e.getMessage()));
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String, String>> handleBadRequest(IllegalArgumentException e) {
        return ResponseEntity.badRequest().body(Map.of("error", e.getMessage()));
    }

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, String>> handleValidation(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldErrors().stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.joining(", "));
        return ResponseEntity.badRequest().body(Map.of("error", message));
    }
}
```

#### JPA Auditing 활성화 (잊지 말 것)

```java
@SpringBootApplication
@EnableJpaAuditing
public class BoardApplication {
    public static void main(String[] args) {
        SpringApplication.run(BoardApplication.class, args);
    }
}
```

---

### Frontend: React + JavaScript

#### Step 1. 프로젝트 생성

```bash
npm create vite@latest board-frontend -- --template react
cd board-frontend
npm install
npm install axios react-router-dom
```

#### Step 2. 프로젝트 구조

```
src/
├── api/
│   └── axios.js           # Axios 인스턴스 + 인터셉터
├── components/
│   ├── Layout.jsx          # 공통 레이아웃 (헤더 + 네비게이션)
│   ├── PostCard.jsx        # 게시글 목록 아이템
│   ├── CommentItem.jsx     # 댓글 아이템
│   ├── Pagination.jsx      # 페이지네이션
│   └── ProtectedRoute.jsx  # 로그인 필요 라우트
├── pages/
│   ├── LoginPage.jsx       # 로그인
│   ├── SignupPage.jsx      # 회원가입
│   ├── PostListPage.jsx    # 게시글 목록
│   ├── PostDetailPage.jsx  # 게시글 상세 + 댓글
│   ├── PostCreatePage.jsx  # 게시글 작성
│   └── PostEditPage.jsx    # 게시글 수정
├── hooks/
│   └── useAuth.js          # 인증 상태 관리 커스텀 훅
├── context/
│   └── AuthContext.jsx      # 인증 Context
├── App.jsx
└── main.jsx
```

#### Step 3. Axios 설정 — 여기서 익힐 것: 인터셉터, 토큰 관리

```jsx
// src/api/axios.js
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:8080/api',
});

// 요청 인터셉터: 매 요청에 JWT 토큰 자동 첨부
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 응답 인터셉터: 401이면 토큰 삭제 + 로그인으로 리다이렉트
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      localStorage.removeItem('username');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

#### Step 4. 인증 Context — 여기서 익힐 것: createContext, useContext, useEffect

```jsx
// src/context/AuthContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import api from '../api/axios';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // 마운트 시 localStorage에서 토큰 확인
  useEffect(() => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username');
    if (token && username) {
      setUser({ token, username });
    }
    setLoading(false);
  }, []);

  const login = async (username, password) => {
    const res = await api.post('/auth/login', { username, password });
    localStorage.setItem('token', res.data.token);
    localStorage.setItem('username', res.data.username);
    setUser({ token: res.data.token, username: res.data.username });
  };

  const signup = async (username, password) => {
    const res = await api.post('/auth/signup', { username, password });
    localStorage.setItem('token', res.data.token);
    localStorage.setItem('username', res.data.username);
    setUser({ token: res.data.token, username: res.data.username });
  };

  const logout = () => {
    localStorage.removeItem('token');
    localStorage.removeItem('username');
    setUser(null);
  };

  if (loading) return <div>로딩 중...</div>;

  return (
    <AuthContext.Provider value={{ user, login, signup, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
```

#### Step 5. 라우팅 — 여기서 익힐 것: React Router v6, ProtectedRoute

```jsx
// src/App.jsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './context/AuthContext';
import Layout from './components/Layout';
import ProtectedRoute from './components/ProtectedRoute';
import LoginPage from './pages/LoginPage';
import SignupPage from './pages/SignupPage';
import PostListPage from './pages/PostListPage';
import PostDetailPage from './pages/PostDetailPage';
import PostCreatePage from './pages/PostCreatePage';
import PostEditPage from './pages/PostEditPage';

function App() {
  return (
    <AuthProvider>
      <BrowserRouter>
        <Routes>
          <Route element={<Layout />}>
            <Route path="/" element={<PostListPage />} />
            <Route path="/login" element={<LoginPage />} />
            <Route path="/signup" element={<SignupPage />} />
            <Route path="/posts/:id" element={<PostDetailPage />} />
            <Route element={<ProtectedRoute />}>
              <Route path="/posts/new" element={<PostCreatePage />} />
              <Route path="/posts/:id/edit" element={<PostEditPage />} />
            </Route>
          </Route>
        </Routes>
      </BrowserRouter>
    </AuthProvider>
  );
}

export default App;

// src/components/ProtectedRoute.jsx
import { Navigate, Outlet } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

function ProtectedRoute() {
  const { user } = useAuth();
  return user ? <Outlet /> : <Navigate to="/login" replace />;
}

export default ProtectedRoute;
```

#### Step 6. 레이아웃 — 여기서 익힐 것: Outlet, 조건부 렌더링, Link

```jsx
// src/components/Layout.jsx
import { Link, Outlet } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

function Layout() {
  const { user, logout } = useAuth();

  return (
    <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px' }}>
      <header style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '20px' }}>
        <Link to="/" style={{ fontSize: '24px', fontWeight: 'bold', textDecoration: 'none' }}>
          게시판
        </Link>
        <nav>
          {user ? (
            <>
              <span>{user.username}님 </span>
              <Link to="/posts/new">글쓰기</Link>
              {' | '}
              <button onClick={logout}>로그아웃</button>
            </>
          ) : (
            <>
              <Link to="/login">로그인</Link>
              {' | '}
              <Link to="/signup">회원가입</Link>
            </>
          )}
        </nav>
      </header>
      <main>
        <Outlet />
      </main>
    </div>
  );
}

export default Layout;
```

#### Step 7. 게시글 목록 — 여기서 익힐 것: useEffect, useState, API 호출, 페이징, 검색

```jsx
// src/pages/PostListPage.jsx
import { useState, useEffect } from 'react';
import { Link, useSearchParams } from 'react-router-dom';
import api from '../api/axios';

function PostListPage() {
  const [posts, setPosts] = useState([]);
  const [totalPages, setTotalPages] = useState(0);
  const [searchParams, setSearchParams] = useSearchParams();

  const page = parseInt(searchParams.get('page') || '0');
  const keyword = searchParams.get('keyword') || '';
  const [searchInput, setSearchInput] = useState(keyword);

  // 페이지나 키워드가 바뀔 때마다 API 호출
  useEffect(() => {
    const params = { page, size: 10 };
    if (keyword) params.keyword = keyword;

    api.get('/posts', { params })
      .then((res) => {
        setPosts(res.data.content);
        setTotalPages(res.data.totalPages);
      })
      .catch((err) => console.error(err));
  }, [page, keyword]);

  const handleSearch = (e) => {
    e.preventDefault();
    setSearchParams({ keyword: searchInput, page: '0' });
  };

  const goToPage = (newPage) => {
    const params = { page: String(newPage) };
    if (keyword) params.keyword = keyword;
    setSearchParams(params);
  };

  return (
    <div>
      {/* 검색 */}
      <form onSubmit={handleSearch} style={{ marginBottom: '20px' }}>
        <input
          value={searchInput}
          onChange={(e) => setSearchInput(e.target.value)}
          placeholder="제목으로 검색..."
        />
        <button type="submit">검색</button>
      </form>

      {/* 게시글 목록 */}
      <table style={{ width: '100%', borderCollapse: 'collapse' }}>
        <thead>
          <tr>
            <th>번호</th>
            <th>제목</th>
            <th>작성자</th>
            <th>작성일</th>
          </tr>
        </thead>
        <tbody>
          {posts.map((post) => (
            <tr key={post.id}>
              <td>{post.id}</td>
              <td>
                <Link to={`/posts/${post.id}`}>
                  {post.title}
                  {post.commentCount > 0 && ` [${post.commentCount}]`}
                </Link>
              </td>
              <td>{post.author}</td>
              <td>{new Date(post.createdAt).toLocaleDateString()}</td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* 페이지네이션 */}
      <div style={{ marginTop: '20px', textAlign: 'center' }}>
        <button onClick={() => goToPage(page - 1)} disabled={page === 0}>
          이전
        </button>
        <span> {page + 1} / {totalPages} </span>
        <button onClick={() => goToPage(page + 1)} disabled={page >= totalPages - 1}>
          다음
        </button>
      </div>
    </div>
  );
}

export default PostListPage;
```

#### Step 8. 게시글 상세 — 여기서 익힐 것: useParams, 댓글 CRUD, 조건부 렌더링

```jsx
// src/pages/PostDetailPage.jsx
import { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import api from '../api/axios';
import { useAuth } from '../context/AuthContext';

function PostDetailPage() {
  const { id } = useParams();
  const navigate = useNavigate();
  const { user } = useAuth();

  const [post, setPost] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [commentInput, setCommentInput] = useState('');

  // 게시글 조회
  useEffect(() => {
    api.get(`/posts/${id}`)
      .then((res) => setPost(res.data))
      .catch((err) => setError(err.response?.data?.error || '오류가 발생했습니다'))
      .finally(() => setLoading(false));
  }, [id]);

  // 게시글 삭제
  const handleDelete = async () => {
    if (!window.confirm('정말 삭제하시겠습니까?')) return;
    try {
      await api.delete(`/posts/${id}`);
      navigate('/');
    } catch (err) {
      alert(err.response?.data?.error || '삭제 실패');
    }
  };

  // 댓글 작성
  const handleCommentSubmit = async (e) => {
    e.preventDefault();
    if (!commentInput.trim()) return;
    try {
      const res = await api.post(`/posts/${id}/comments`, { content: commentInput });
      setPost((prev) => ({
        ...prev,
        comments: [res.data, ...prev.comments],
      }));
      setCommentInput('');
    } catch (err) {
      alert(err.response?.data?.error || '댓글 작성 실패');
    }
  };

  // 댓글 삭제
  const handleCommentDelete = async (commentId) => {
    try {
      await api.delete(`/posts/${id}/comments/${commentId}`);
      setPost((prev) => ({
        ...prev,
        comments: prev.comments.filter((c) => c.id !== commentId),
      }));
    } catch (err) {
      alert(err.response?.data?.error || '댓글 삭제 실패');
    }
  };

  if (loading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error}</div>;
  if (!post) return <div>게시글을 찾을 수 없습니다.</div>;

  const isAuthor = user?.username === post.author;

  return (
    <div>
      {/* 게시글 */}
      <h1>{post.title}</h1>
      <div>
        <span>작성자: {post.author}</span>
        <span> | {new Date(post.createdAt).toLocaleString()}</span>
        {post.updatedAt !== post.createdAt && (
          <span> (수정됨: {new Date(post.updatedAt).toLocaleString()})</span>
        )}
      </div>

      <div style={{ margin: '20px 0', minHeight: '200px', whiteSpace: 'pre-wrap' }}>
        {post.content}
      </div>

      {/* 본인 글이면 수정/삭제 버튼 */}
      {isAuthor && (
        <div>
          <Link to={`/posts/${id}/edit`}>수정</Link>
          {' | '}
          <button onClick={handleDelete}>삭제</button>
        </div>
      )}

      <hr />

      {/* 댓글 */}
      <h3>댓글 ({post.comments.length})</h3>

      {user && (
        <form onSubmit={handleCommentSubmit} style={{ marginBottom: '20px' }}>
          <textarea
            value={commentInput}
            onChange={(e) => setCommentInput(e.target.value)}
            placeholder="댓글을 입력하세요..."
            rows={3}
            style={{ width: '100%' }}
          />
          <button type="submit">댓글 작성</button>
        </form>
      )}

      {post.comments.map((comment) => (
        <div key={comment.id} style={{ padding: '10px', borderBottom: '1px solid #eee' }}>
          <strong>{comment.author}</strong>
          <span> | {new Date(comment.createdAt).toLocaleString()}</span>
          {user?.username === comment.author && (
            <button onClick={() => handleCommentDelete(comment.id)}>삭제</button>
          )}
          <p>{comment.content}</p>
        </div>
      ))}
    </div>
  );
}

export default PostDetailPage;
```

#### Step 9. 글 작성/수정 — 여기서 익힐 것: 폼 핸들링, useNavigate, 조건부 데이터 로드

```jsx
// src/pages/PostCreatePage.jsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../api/axios';

function PostCreatePage() {
  const navigate = useNavigate();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const res = await api.post('/posts', { title, content });
      navigate(`/posts/${res.data.id}`);
    } catch (err) {
      setError(err.response?.data?.error || '작성 실패');
    }
  };

  return (
    <div>
      <h1>글쓰기</h1>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="제목"
            required
            style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
          />
        </div>
        <div>
          <textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="내용"
            required
            rows={15}
            style={{ width: '100%', padding: '8px' }}
          />
        </div>
        <button type="submit">작성</button>
        <button type="button" onClick={() => navigate(-1)}>취소</button>
      </form>
    </div>
  );
}

export default PostCreatePage;

// src/pages/PostEditPage.jsx
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import api from '../api/axios';

function PostEditPage() {
  const { id } = useParams();
  const navigate = useNavigate();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // 기존 글 데이터 로드
  useEffect(() => {
    api.get(`/posts/${id}`)
      .then((res) => {
        setTitle(res.data.title);
        setContent(res.data.content);
      })
      .catch((err) => setError(err.response?.data?.error || '오류'))
      .finally(() => setLoading(false));
  }, [id]);

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await api.put(`/posts/${id}`, { title, content });
      navigate(`/posts/${id}`);
    } catch (err) {
      setError(err.response?.data?.error || '수정 실패');
    }
  };

  if (loading) return <div>로딩 중...</div>;

  return (
    <div>
      <h1>글 수정</h1>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <input
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            placeholder="제목"
            required
            style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
          />
        </div>
        <div>
          <textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            placeholder="내용"
            required
            rows={15}
            style={{ width: '100%', padding: '8px' }}
          />
        </div>
        <button type="submit">수정</button>
        <button type="button" onClick={() => navigate(-1)}>취소</button>
      </form>
    </div>
  );
}

export default PostEditPage;
```

#### Step 10. 로그인/회원가입 — 여기서 익힐 것: 폼, 에러 처리, 리다이렉트

```jsx
// src/pages/LoginPage.jsx
import { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

function LoginPage() {
  const navigate = useNavigate();
  const { login } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await login(username, password);
      navigate('/');
    } catch (err) {
      setError(err.response?.data?.error || '로그인 실패');
    }
  };

  return (
    <div style={{ maxWidth: '400px', margin: '0 auto' }}>
      <h1>로그인</h1>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <input
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            placeholder="아이디"
            required
            style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
          />
        </div>
        <div>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="비밀번호"
            required
            style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
          />
        </div>
        <button type="submit" style={{ width: '100%', padding: '10px' }}>로그인</button>
      </form>
      <p>계정이 없으신가요? <Link to="/signup">회원가입</Link></p>
    </div>
  );
}

export default LoginPage;

// src/pages/SignupPage.jsx
import { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

function SignupPage() {
  const navigate = useNavigate();
  const { signup } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await signup(username, password);
      navigate('/');
    } catch (err) {
      setError(err.response?.data?.error || '회원가입 실패');
    }
  };

  return (
    <div style={{ maxWidth: '400px', margin: '0 auto' }}>
      <h1>회원가입</h1>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <form onSubmit={handleSubmit}>
        <div>
          <input
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            placeholder="아이디 (3자 이상)"
            required
            style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
          />
        </div>
        <div>
          <input
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="비밀번호 (4자 이상)"
            required
            style={{ width: '100%', padding: '8px', marginBottom: '10px' }}
          />
        </div>
        <button type="submit" style={{ width: '100%', padding: '10px' }}>회원가입</button>
      </form>
      <p>이미 계정이 있으신가요? <Link to="/login">로그인</Link></p>
    </div>
  );
}

export default SignupPage;
```

---

## CORS 설정 (Backend에 추가, 잊기 쉬움)

```java
@Configuration
public class CorsConfig {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**")
                    .allowedOrigins("http://localhost:5173")  // Vite 기본 포트
                    .allowedMethods("GET", "POST", "PUT", "DELETE")
                    .allowedHeaders("*");
            }
        };
    }
}
```

---

## 2차: Kotlin + Spring Boot + React(TS)로 포팅

1차를 완성한 후, 같은 기능을 아래와 같이 변환한다.

### Backend: Java → Kotlin 전환 포인트

|Java|Kotlin|
|---|---|
|`public class User { ... }`|`class User( ... )`|
|Lombok `@Getter`, `@NoArgsConstructor`|불필요 (data class, 기본 파라미터)|
|`record PostCreateRequest(...)`|`data class PostCreateRequest(...)`|
|`Optional<User>`|`User?` + `?:`, `?.let {}`|
|`.stream().map().collect()`|`.map {}` 바로 사용|
|`new User(name, password)`|`User(name, password)` (new 없음)|
|`if (x != null) { x.method() }`|`x?.method()`|
|`throw new EntityNotFoundException(...)`|`throw EntityNotFoundException(...)`|
|`String.format("Hello %s", name)`|`"Hello $name"`|
|`Collections.unmodifiableList(...)`|`listOf(...)`|
|`var list = new ArrayList<>()`|`val list = mutableListOf<Type>()`|

**Kotlin Entity 예시 (Java와 비교)**

```kotlin
@Entity
@Table(name = "posts")
@EntityListeners(AuditingEntityListener::class)
class Post(
    @Column(nullable = false, length = 100)
    var title: String,

    @Column(nullable = false, columnDefinition = "TEXT")
    var content: String,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    val user: User,

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0,

    @OneToMany(mappedBy = "post", cascade = [CascadeType.ALL], orphanRemoval = true)
    val comments: MutableList<Comment> = mutableListOf(),

    @CreatedDate
    @Column(updatable = false)
    var createdAt: LocalDateTime = LocalDateTime.now(),

    @LastModifiedDate
    var updatedAt: LocalDateTime = LocalDateTime.now()
) {
    fun update(title: String, content: String) {
        this.title = title
        this.content = content
    }
}
```

**Kotlin Service 예시**

```kotlin
@Service
@Transactional(readOnly = true)
class PostService(
    private val postRepository: PostRepository,
    private val userRepository: UserRepository
) {
    fun getPosts(page: Int, size: Int): Page<PostListResponse> {
        val pageable = PageRequest.of(page, size, Sort.by("createdAt").descending())
        return postRepository.findAll(pageable).map { PostListResponse.from(it) }
    }

    fun getPost(id: Long): PostDetailResponse {
        val post = postRepository.findById(id)
            .orElseThrow { EntityNotFoundException("게시글을 찾을 수 없습니다.") }
        return PostDetailResponse.from(post)
    }

    @Transactional
    fun createPost(request: PostCreateRequest, userId: Long): PostDetailResponse {
        val user = userRepository.findById(userId)
            .orElseThrow { EntityNotFoundException("사용자를 찾을 수 없습니다.") }
        val post = Post(title = request.title, content = request.content, user = user)
        postRepository.save(post)
        return PostDetailResponse.from(post)
    }

    @Transactional
    fun updatePost(id: Long, request: PostUpdateRequest, userId: Long): PostDetailResponse {
        val post = postRepository.findById(id)
            .orElseThrow { EntityNotFoundException("게시글을 찾을 수 없습니다.") }

        require(post.user.id == userId) { "본인의 글만 수정할 수 있습니다." }

        post.update(request.title, request.content)
        return PostDetailResponse.from(post)
    }

    @Transactional
    fun deletePost(id: Long, userId: Long) {
        val post = postRepository.findById(id)
            .orElseThrow { EntityNotFoundException("게시글을 찾을 수 없습니다.") }

        require(post.user.id == userId) { "본인의 글만 삭제할 수 있습니다." }

        postRepository.delete(post)
    }
}
```

### Frontend: JS → TypeScript 전환 포인트

|JS|TypeScript|
|---|---|
|`const [post, setPost] = useState(null)`|`const [post, setPost] = useState<PostDetail \| null>(null)`|
|`function PostCard({ post })`|`function PostCard({ post }: { post: PostListItem })`|
|`const res = await api.get(...)`|`const res = await api.get<PageResponse<PostListItem>>(...)`|
|타입 없음|interface로 API 응답 타입 전부 정의|
|`e.target.value`|`e: React.ChangeEvent<HTMLInputElement>`|

**TypeScript 타입 정의 (src/types/index.ts)**

```typescript
// API 응답 타입
export interface PostListItem {
  id: number;
  title: string;
  author: string;
  commentCount: number;
  createdAt: string;
}

export interface PostDetail {
  id: number;
  title: string;
  content: string;
  author: string;
  authorId: number;
  comments: CommentItem[];
  createdAt: string;
  updatedAt: string;
}

export interface CommentItem {
  id: number;
  content: string;
  author: string;
  authorId: number;
  createdAt: string;
}

export interface PageResponse<T> {
  content: T[];
  totalPages: number;
  totalElements: number;
  number: number;
  size: number;
}

// Request 타입
export interface LoginRequest {
  username: string;
  password: string;
}

export interface PostCreateRequest {
  title: string;
  content: string;
}

export interface TokenResponse {
  token: string;
  username: string;
}

// Auth Context 타입
export interface AuthUser {
  token: string;
  username: string;
}

export interface AuthContextType {
  user: AuthUser | null;
  login: (username: string, password: string) => Promise<void>;
  signup: (username: string, password: string) => Promise<void>;
  logout: () => void;
}
```

**TypeScript AuthContext 예시**

```tsx
// src/context/AuthContext.tsx
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import api from '../api/axios';
import { AuthUser, AuthContextType, TokenResponse } from '../types';

const AuthContext = createContext<AuthContextType | null>(null);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<AuthUser | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    const token = localStorage.getItem('token');
    const username = localStorage.getItem('username');
    if (token && username) {
      setUser({ token, username });
    }
    setLoading(false);
  }, []);

  const login = async (username: string, password: string): Promise<void> => {
    const res = await api.post<TokenResponse>('/auth/login', { username, password });
    localStorage.setItem('token', res.data.token);
    localStorage.setItem('username', res.data.username);
    setUser({ token: res.data.token, username: res.data.username });
  };

  const signup = async (username: string, password: string): Promise<void> => {
    const res = await api.post<TokenResponse>('/auth/signup', { username, password });
    localStorage.setItem('token', res.data.token);
    localStorage.setItem('username', res.data.username);
    setUser({ token: res.data.token, username: res.data.username });
  };

  const logout = (): void => {
    localStorage.removeItem('token');
    localStorage.removeItem('username');
    setUser(null);
  };

  if (loading) return <div>로딩 중...</div>;

  return (
    <AuthContext.Provider value={{ user, login, signup, logout }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth(): AuthContextType {
  const context = useContext(AuthContext);
  if (!context) throw new Error('useAuth must be used within AuthProvider');
  return context;
}
```

**TypeScript PostListPage 예시**

```tsx
// src/pages/PostListPage.tsx
import { useState, useEffect } from 'react';
import { Link, useSearchParams } from 'react-router-dom';
import api from '../api/axios';
import { PostListItem, PageResponse } from '../types';

function PostListPage() {
  const [posts, setPosts] = useState<PostListItem[]>([]);
  const [totalPages, setTotalPages] = useState<number>(0);
  const [searchParams, setSearchParams] = useSearchParams();

  const page: number = parseInt(searchParams.get('page') || '0');
  const keyword: string = searchParams.get('keyword') || '';
  const [searchInput, setSearchInput] = useState<string>(keyword);

  useEffect(() => {
    const params: Record<string, string | number> = { page, size: 10 };
    if (keyword) params.keyword = keyword;

    api.get<PageResponse<PostListItem>>('/posts', { params })
      .then((res) => {
        setPosts(res.data.content);
        setTotalPages(res.data.totalPages);
      })
      .catch((err: Error) => console.error(err));
  }, [page, keyword]);

  const handleSearch = (e: React.FormEvent<HTMLFormElement>): void => {
    e.preventDefault();
    setSearchParams({ keyword: searchInput, page: '0' });
  };

  // ... 나머지는 JS 버전과 동일하되 타입만 추가
}
```

---

## 시간 배분

### 1차: Java + React(JS) — 12~15시간

|작업|시간|
|---|---|
|Backend: Entity + Repository + DTO|2h|
|Backend: Service + Controller|2h|
|Backend: JWT + Security + 예외처리|2h|
|Frontend: 프로젝트 세팅 + Axios + Auth|2h|
|Frontend: 목록 + 상세 페이지|2h|
|Frontend: 작성/수정 + 로그인/가입|2h|
|연동 + 디버깅 + CORS|1~2h|

### 2차: Kotlin + React(TS) 포팅 — 8~10시간

|작업|시간|
|---|---|
|Backend: Java → Kotlin 전환|3~4h|
|Frontend: JS → TypeScript 전환 (타입 정의 + 적용)|3~4h|
|연동 + 디버깅|1~2h|

### 합계: 20~25시간

---

## 완성 후 셀프 체크

- [ ] 회원가입 → 로그인 → 토큰 발급 흐름을 설명할 수 있다
- [ ] JPA Entity 연관관계를 안 보고 칠 수 있다 (1:N, N:1)
- [ ] @Transactional이 왜 필요한지, readOnly=true가 뭔지 설명할 수 있다
- [ ] Spring Security 필터 체인 흐름을 설명할 수 있다
- [ ] useEffect의 의존성 배열이 왜 필요한지 설명할 수 있다
- [ ] useState로 로딩/에러/데이터 3가지 상태를 관리할 수 있다
- [ ] React Router의 useParams, useNavigate, useSearchParams를 쓸 수 있다
- [ ] Java와 Kotlin의 주요 차이점 5가지를 바로 말할 수 있다
- [ ] JS와 TS의 타입 정의 패턴을 바로 쓸 수 있다