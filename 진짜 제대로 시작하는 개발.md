**반드시 지켜야 하는것**
- 막히면 최소 30분 고민
- AI사용 : 짜기 전 → 개념 질문만 OK. 짜고 나서 → 내 코드 검토 요청 OK. 코드 짜달라고 하는 건 NG.
- 스택 최소화 : React, TypeScript, TanStack Query, Spring Boot, JPA
- 개발하는날 매일 3줄 기록 : 뭘 짰는가, 어디서 막혔는가, 어떻게 해결했는가
- 짜다가 막힌거는 Anki에 기록
- 환경세팅은 처음에 잡기(환경변수 분리, DB 설정등)
- 새 기술 도입기 공식문서 Getting Started정도만 읽기, 강의 먼저 듣지 않기

PostgreSql 접속정보 (local) -> 아이폰 메모

[[PostgreSql 관련]]

###### 프로젝트 시나리오
논리 시나리오

직책에 따라
빌릴 수 있는거
빌릴 수 없는거 있음

권한에 따라
직책이 낮아도 관리가 가능함

비품이 
소모품이면 : 개인번호 생성 안함, 따로 반남 필요없음
소모품이 아니면 : 개인번호 생성 및 추적?

반납로직은 본인이 반납후 반납 QR찍음(직접 일일이 QR찍어서 확인할 수 없기때문에)
반납 완료 상태보고, 관리자가 직접 확인

대여 승인이 완료됐을시
모든 제품에 대해 자동으로 대여중 으로 표기
반납대기중으로 표시, 각각의 제품들을 QR찍어서 반납했을시, 반납완료로 자동표기

QR을 쓴 반납 프로세스
승인이 떨어짐 -> 승인이 떨어진 물품에 한해서 사용자가 직접 QR을 찍음 -> 대여 시점및 그 물품의 대여 상황을 알 수 있음 -> 사용자는 사용이 끝난 물품을 관리자에가 갔다주던가 반납존에 가져다줌 -> 관리자는 QR을 찍어서 물품 반납을 확인함

내가 왜 QR을 쓰려고하지? ( equip - request )
원래는 승인완료 프로세스에서 끝이였는데
이렇게 되면 그 물품이 반납이 됐는지 안됐는지 알수가없으니 반납을 
간단하게 확인하기 위해서 QR반납을 만들었음

###### Table 구조
osm - erd 테이블 구조 이미지
![[Pasted image 20260221154730.png]]
###### CREATE SQL(Java Entity만들고 나중에 수정 필요)
```sql
CREATE TABLE users (
    user_id         BIGINT          NOT NULL,
    email           VARCHAR(100)    NOT NULL UNIQUE,
    password        VARCHAR(255)    NOT NULL,
    name            VARCHAR(50)     NOT NULL,
    job_title       VARCHAR(50)     NOT NULL,
    role            VARCHAR(50)     NOT NULL,
    updated_at      TIMESTAMP       NOT NULL,
    created_at      TIMESTAMP       NOT NULL,
    PRIMARY KEY (user_id)
);

CREATE TABLE office_supplies (
    office_supply_id    BIGINT          NOT NULL,
    name                VARCHAR(255)    NOT NULL,
    category            VARCHAR(50)     NOT NULL,
    quantity            INT             NOT NULL,
    description         TEXT            NULL,
    allowed_job_titles  VARCHAR(50)     NULL,
    asset_number        VARCHAR(255)    NULL,
    status              VARCHAR(50)     NULL,
    usage_type          VARCHAR(50)     NULL,
    image               VARCHAR(500)    NULL,
    is_deleted          BOOLEAN         NOT NULL DEFAULT FALSE,
    updated_at          TIMESTAMP       NOT NULL,
    created_at          TIMESTAMP       NOT NULL,
    PRIMARY KEY (office_supply_id)
);

CREATE TABLE office_supply_requests (
    office_supply_request_id    BIGINT          NOT NULL,
    user_id                     BIGINT          NOT NULL,
    status                      VARCHAR(50)     NOT NULL,
    rejection_reason            TEXT            NULL,
    approver                    VARCHAR(50)     NOT NULL,
    updated_at                  TIMESTAMP       NOT NULL,
    created_at                  TIMESTAMP       NOT NULL,
    PRIMARY KEY (office_supply_request_id),
);

CREATE TABLE office_supply_drafts (
    office_supply_draft_id      BIGINT          NOT NULL,
    office_supply_id            BIGINT          NOT NULL,
    office_supply_request_id    BIGINT          NULL,
    user_id                     BIGINT          NOT NULL,
    quantity                    INT             NOT NULL,
    status                      VARCHAR(50)     NOT NULL,
    updated_at                  TIMESTAMP       NOT NULL,
    created_at                  TIMESTAMP       NOT NULL,
    PRIMARY KEY (office_supply_draft_id),
);

CREATE TABLE office_supply_records (
    office_supply_record_id BIGINT          NOT NULL,
    office_supply_id        BIGINT          NOT NULL,
    borrower_name           VARCHAR(50)     NULL,
    borrower_job_title      VARCHAR(50)     NULL,
    approver                VARCHAR(50)     NULL,
    status                  VARCHAR(50)     NULL,
    updated_at              TIMESTAMP       NOT NULL,
    created_at              TIMESTAMP       NOT NULL,
    PRIMARY KEY (office_supply_record_id),
);
```

###### 개발 기록
**뭘 했는가**
ERD 설계 

**어디서 막혔는가**
변수 이름, 테이블명, 논리 구조, 소프트 딜리트와 같이 자잘한 것에서 막힘

**어떻게 해결했는가**
AI를 사용해서 모르는 걸 물어보고 개인적으로 고민하고 이해해서 해결함? 필요한것들은 정리



**@MappedSuperclass**는 어떨때 쓰나? 
클래스를 테이블로 만들지 않고, 상속받는 엔티티들한테 필드만 물려주고 싶을 때
`id`, `createdAt`, `updatedAt` 등과 같은 공통 필드들을 모아둔다.

**@EntityListeners(AuditingEntityListener.class)** 를 사용하는 이유와 반드시 같이 써야하는 어노테이션은? 
JPA가 엔티티 저장/수정될 때 자동으로 날짜 채우기 위해 없을시
`@CreatedDate`, `@LastModifiedDate` 동작 하지 않음
메인 클래스에 `@EnableJpaAuditing` 과 함께 사용
